# 粒子系统

## 简介

**粒子系统 (Particle System)**组件通过在场景中生成和动画化大量小型 2D 图像来模拟流体实体，如液体、云和火焰。

粒子系统的操作主要由以下的模块构成，你所看到的千变万化风格的特效，除了导入的贴图外，它们的变化很大程度上依赖于这些模块和和模块中的属性。

- Particle System：初始化模块
- Emission：发射模块
- Shape：发射器形状模块
- Velocity over Lifetime：生命周期内速度变化模块
- Limit Velocity over Lifetime：生命周期内速度约束模块
- Inherit Velocity：继承父对象的速度，粒子速度会受到其父对象移动的影响
- Force over Lifetime：生命周期内受力变化模块
- Color over Lifetime：生命周期内颜色变化模块
- Color by Speed：颜色受速度的影响模块
- Size over Lifetime：生命周期内粒子大小变化模块
- Size by Speed：粒子大小受速度影响模块
- Rotation over Lifetime：生命周期内方向变化模块
- Rotation by Speed：方向受速度影响模块
- External Forces：粒子受外力影响模块
- Noise：粒子受到随机噪声影响模块
- Collision：碰撞模块
- Triggers：触发器模块，如粒子雨，使粒子不会达到屋内
- Sub Emitters：子发射器模块，多个粒子系统并行或串行发射粒子
- Texture Sheet Animation：纹理层动画模块，可以控制将一张图片分割成多个部分，每次将其中的一个部分取出作为粒子贴图
- Lights：光照模块
- Trails：拖尾模块，可以给粒子添加拖尾效果
- Custom Data：自定义模块，为粒子自定义数据
- Renderer：渲染模块，可以设置渲染材质球、拖尾材质球等

## 属性介绍

### duration（持续时间）

表示粒子的**发射**时间长度，如果勾选了Looping属性，该值将无什么作用，不管是持续时间2秒3秒4秒还是几秒，都是循环也就是一直发射。

### Looping：（循环）

表示当前粒子在【Duration持续时间】属性里面的发射时间结束后重新启动并一直反复循环下去。

### prewarm（预热）

**只有Looping启动的时候有效**，如果不勾选当你运行项目粒子默认是从无到有显示出来的，从周期的**开始状态**执行Looping，如果勾选，运行项目会直接看到粒子，也就是从一个周期的**结束状态**执行Looping。

#### 性能热点：预热会引发加载性能热点，出现卡顿帧

### Start Delay（开始延迟）

如果不为0，粒子会在延迟指定秒后才开始发射，可以是常量，也可以是随机值。**如果【Prewarm-预热】激活，该值不可用**。

### Start Lifetime（生存时间）

粒子发射出来后粒子的存在时长，以秒为单位，到达后消亡，所有可以是一个常量，每个也可以是随机值。

### Start Speed（开始速度）

粒子的发射速度，可以是常量，每个也可以随机不同的值。

### 3D Start Size-控制粒子大小

如果勾选，可以分别控制x轴y轴z轴的大小，每个粒子会放大，默认为1，当你操作的时候发现x和y有直观的效果，z修改肉眼看不出，其实多数粒子效果都是2D的只需要x和y，z在特殊情况使用，我记着是mesh模型中

### Start Size-粒子的初始大小

和【3D Start Size】相同，这个是2D的，x和y等比缩放，【3D Start Size】是xyz能缩放不同值。【Start Size】和【3D Start Size】互斥。

### 3D Start Rotation-3D旋转

激活后，可控制xyz不同的旋转值，默认看不出效果，当你的粒子是不规则形状（3D网格粒子）的时候肉眼就能看出来了。

### Start Rotation-2D旋转

2D平面的旋转角度，正数是顺时针旋转，负数是逆时针旋转，可以是区间随机值，和【3D Start Rotation】属性互斥。

### Flip Rotation-翻转旋转

输入0至1之间的值，值越大翻转的越多，1代表翻转所有，举例【Start Rotation】属性将粒子顺时针旋转60度，如果【Flip Rotation】为0.5，则改粒子系统产生的所有粒子一半是60度，一半是-60度，如果是1，则全部粒子为-60度旋转。该属性同样适用于【3D Start Rotation】。

### Start Color

设置每个粒子的起始颜色，可以是某个固定颜色或多个颜色随机，可以是一个渐变区间随机颜色，也可以是多个渐变区间随机颜色。

### **Gravity Modifier：**

值为0关闭粒子重力，如果不为零，粒子重力计算方式【输入数值乘Edit > Project Settings > Gravity设置的值（默认Y轴是-9.8）】。例Gravity Modifier值为2，则粒子的重力是2*(-9.8)=-19.6。

**值越大，物体将以越快的速度向下掉，值越小，物体将以越快的速度向上发射。**

### Simulation Space-模拟空间

控制粒子的移动位置是相对父布局的还是相对于世界的。有三个可选值（局部-世界-自定义）。局部代表你移动粒子系统物体的时候，该物体的所有粒子会同时移动，世界代表你移动粒子系统物体的时候，已经发射出的粒子保留在场景世界中坐标位置，新的粒子会在你移动后的位置发射。自定义你可以创建一个带Transform的GameObject，移动整个粒子系统，产生的粒子会将该自定义的Transform当参照物适配坐标。举例火焰弹道移动有火星散发，Simulation Space选择（世界）比较合适。

**简言之：设置为世界的时候，粒子发射会随着粒子位置的变化而变化。反之则不会。**

### Simulation Speed-模拟速度

缩放调整整个粒子系统的播放速度。该属性数值乘【Start Speed】属性数值是粒子的最终速度。

### Delta Time-增量时间

提供两个选项Scaled和Unscaled，选择Scaled则使用Edit>Project Settings>Time中的数值，Unscaled代表不受其控制，在游戏场景中默认使用Scaled，而在暂停场景业务中比如回合制暂停，RPG暂停弹出的人物属性包裹等窗口如有粒子效果，使用Unscaled。

### **inherit velocity（继承速度）：**

使用它时必须把Simulation Space设置为world，他的效果也和它的名字一样，**粒子发射的时候将会继承你移动坐标系时候的速度和方向。**

### Play on Awake

如果启用此属性，则粒子系统会在创建对象时自动启动。

### Max Particles

系统中同时存在的最大粒子数。如果达到极限，一些粒子将被移除。

### Emitter Velocity

两个选项，Transform，Rigidbody。当粒子移动时，系统根据哪一种来计算速率。

### Stop Action

结束动作。当粒子结束播放，如何操作Gameobject，时disable还是Destroy。或者什么都不做None。（只在游戏运行时有效）。

### Culling Mode

裁剪模式，粒子在屏幕外面时的处理， Automatic(循环粒子-停止更新，非循环-不停止更新），Pause And Catch-up(停止更新，当返回屏幕内时，补齐这段时间的更新，这会产生性能问题）Pause(停止），Always Simulate(在不在屏幕外，一直更新）

### Ring Buffer Mode

粒子循环利用方式，Disabled（不循环利用），Pause Until Replaced（当数量达到最大上限时，老的粒子停止，去用于产生新的），Loop Until Replaced(当粒子生命结束时，加入新利用循环）

## EMISSION

### rate over time

每个时间单位发射的粒子数目

### rate over distance

每个移动距离单位发射的粒子数，此模式对于模拟实际由对象运动产生的粒子非常有用（例如，泥路上车轮留下的尘土）

### Bursts（爆发）：指生成粒子的一个事件

作用：模拟非线性发射粒子的情况，可自定义在哪个时间点发射多少粒子，可用于模拟爆炸的情况

*Time*设置发射爆发粒子的时间（粒子系统开始播放后的秒数）。

*Count*设置可能发射的粒子数的值。

*Cycles*设置播放爆发次数的值，设置的值越高爆发的粒子也就越多。

*Interval*设置触发每个爆发周期的间隔时间（以秒为单位）的值。

*Probability*控制每个爆发事件生成粒子的可能性。较高的值使系统产生更多的粒子，而值为 1 将保证系统产生粒子。

## Shape

作用：发射体的大小，形状，粒子的发射位置和方向，部分其他属性根据shape的方向变化而变化。

### Shape-Sphere

### Radius

球形半径，数值越大半径越大，这个不用多说了。

### Radius Thickness

发射粒子的体积比例。值为 0 表示从形状的外表面发射粒子。值为 1 表示从整个体积发射粒子。介于两者之间的值将使用体积的一定比例。当这个值为0到1之间的时候会在原球形里面再产生一个小球体，粒子从原球体和小球体之间发射。

### arc：有效发射角度

有效发射角度：

当角度设置为180度

### mode（重要）：

定义 Unity 如何在形状的弧形周围生成粒子。

当此选项设置为**Random**时。Unity 在弧形周围随机生成粒子。

如果使用**Loop，Unity 会在形状的弧形周围依序生成粒子，并在每个周期结束时循环回到起点。**

Ping-Pong与**Loop**基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反。

最后，__Burst Spread__ 模式在形状周围均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。**Burst Spread**最适合与爆发发射一起使用。

### spread

形周围可产生粒子的离散间隔。例如，值为 0 表示允许在弧形周围的任何位置生成粒子，值为 0.1 表示仅在形状周围以 10% 的间隔生成粒子。

### texture

用于为粒子着色和丢弃粒子的纹理。

### Position

将一个偏移应用于生成粒子的发射器形状。

**正值为延坐标轴运行，负值延延坐标轴反向运动。**

### Rotation

旋转生成粒子的发射器形状（球形看不出来，建议切换成锥体来看）

### scale

更改生成粒子的发射器形状的大小。

修改x,y,z方向大小，正值为延坐标轴增长，负值延延坐标轴反向减少。

### **Align to Direction（对齐到方向）**

**修改粒子发射出来的方向。**

**Randomize Direction：（随机方向）**

将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机。

越接近1随机读越大。

**Spherize Direction：**

将粒子方向朝球面方向混合，从它们的[变换](https://link.zhihu.com/?target=http%3A//mdeditor.infra.hq.unity3d.com/%23class-Transform)中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同）**类似于球形的随机方向**。

**Randomize Position：**

以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性。

这个粒子是在发射出去后位置的随机。

## Velocity over Lifetime

可控制粒子在其生命周期内的速度。

### linear X,Y,Z,

粒子在 X、Y 和 Z 轴上的线性速度,用来创建特定方向输出的粒子。你可以在不移动坐标轴的情况下改变粒子的输出方向

**正值向坐标轴指向移动，负值向坐标值反向移动。**

### space**：决定linear坐标系是world还是local。**

### **Orbital X, Y, Z：**粒子围绕 X、Y 和 Z 轴的轨道速度。

### **Offset X, Y, Z：**轨道中心的位置，适用于轨道运行粒子。



**Radial：**粒子远离/朝向中心位置的径向速度。**负数为朝向中心的速度，正数为远离中心的速度**

### Speed Modifier（速度修改器）

在当前行进方向上/周围向粒子的速度应用一个乘数。

## Renderer（渲染器模块）

Render Mode：渲染模式，主要有：Billboard（广告牌，粒子永远面朝相机）、Stretched Billboard（可拉伸广告牌）、Horizontal Billboard（水平广告牌，粒子面朝 Y 轴正方向）、Vertical Billboard（垂直广告牌，粒子面朝 X 轴正方向）、Mesh（网格）；

- Material：粒子材质；
- Trail Material：拖尾特效材质，通常取 Default-Line。

# 粒子特效性能热点

## 网格发射数超过5的粒子系统

粒子的渲染模式可分为两大类：2D的Billboard（公告牌）图形模式和Mesh模式。Billboard是3D游戏中用的非常多的一种技术，使用该模式，粒子会以一个平面的形式存在，并始终以一定的角度对着我们的镜头。举个例子来讲，场景中有一棵树，是实体存在的；但在各种Billboard模式下，你只需要看到这棵树的一个“面”。在展示效果上表现其实一样，但渲染一个“面”和渲染一整个实体，前者在消耗的内存和运算量上会更有优势。

Billboard模式，粒子会始终面向摄像机；

Stretched Billboard模式下，粒子在面向摄像机的同时，会在速度的方向上进行拉伸，可以设置粒子的各种缩放和拉伸效果；

Horizontal Billboard模式下，粒子平面会和XZ面平行；

Vertical Billboard模式下，粒子平面在面向摄像机的同时，会在Y轴方向上直立（垂直于XZ平面）；

而“Mesh”模式就是我们今天的主题。这个模式允许粒子系统发射3D网格而非2D的Billboard，以此来实现更为复杂和贴合需求的粒子效果。

3D网格性能开销显然是高于2D的Billboard的。如果粒子系统的发射的网格数量过大，会带来较高的CPU计算开销、GPU渲染压力甚至较高的堆内存分配。所以我们对使用Mesh进行渲染的粒子系统的“最大粒子数”要求更为严苛。一般的粒子系统中，粒子发射数上限建议不超过30（我们在之前的文章中有进行讨论，详见[《【性能黑榜】掌握了这些规则，你已经战胜了80%的对手！》](https://link.zhihu.com/?target=https%3A//blog.uwa4d.com/archives/UWA_Pipeline14.html)）。经由UWA的测试结果表明：渲染模式为Mesh、网格发射数在不超过5的情况下，能够维持粒子效果和性能消耗上的一个相对平衡。

### 所使用的网格未开启Read/Write选项的粒子系统

由于粒子系统的渲染对象从传统的粒子变成了3D网格，所以引用的网格对象本身的属性也会对整个粒子系统产生影响。在这种情况下，很多针对网格的优化建议也同样适用于Mesh模式下的粒子系统，只不过针对特定应用环境，部分优化建议需要“反着看”。

在之前的文章[《网格优化：溃堤之穴，一个也不能放过》](https://link.zhihu.com/?target=https%3A//blog.uwa4d.com/archives/UWA_Pipeline18.html)中，我们对于网格的Read/Write选项进行过一定的说明。仅仅针对网格而言，我们是不建议开启相关的读写权限。

但是在粒子系统应用中，往往需要去实现各种各样的动态效果。所以当渲染模式为Mesh时，网格就需要开启Read/Write选项以实现对3D网格的动态修改，来更好地实现相应的渲染展示效果。

Unity官方文档告诉我们，网格必须设置为Read/Write Enabled才能在粒子系统上工作。若不开启，在某些设备上运行时，可能会出现模型丢失的情况。可见问答：[https://answer.uwa4d.com/question/5cf732fed27511377098284e](https://link.zhihu.com/?target=https%3A//answer.uwa4d.com/question/5cf732fed27511377098284e)。因此我们将该类异常的资源检测出来，希望研发团队进行规范，防止出现意外的显示结果。

### 引用网格面片数超过500的粒子系统

和上一条规则不同，这条便是网格优化在粒子系统中的正向应用。在以前文章[《那些年给性能埋过的坑，你跳了吗？》](https://link.zhihu.com/?target=https%3A//blog.uwa4d.com/archives/UWA_Pipeline12.html)中，我们对于网格的面片数有过相关的简单讲解。对3D网格而言，过多的面片数会带来内存，加载和渲染上的额外消耗。在粒子系统中也是同样如此。

在Mesh模式下，发射的3D网格对面片数的要求也是同样严苛的。所以开发团队需要在本条规则下，去检查相关粒子系统引用的网格是否存在面片数过多的情况，并视实际的表现效果和性能消耗去决定是否需要做出相关的修改。

### 引用纹理数超过5的粒子系统

在之前的文章[《材质优化：如何正确处理纹理和材质的关系》](https://link.zhihu.com/?target=https%3A//blog.uwa4d.com/archives/UWA_Pipeline21.html)中，我们简单讲了下材质的Shader中引用了过多纹理会在内存和计算上带来的影响。

同样的，在粒子系统中，如果在材质内包含了过多的引用纹理，也同样会导致存储和运算上的额外消耗，从而对整个的粒子系统带来不必要的负担。

所以开发团队在为纹理系统引入材质时，需要关注相关材质内引用的纹理数量。在满足使用的前提下，从材质做瘦身，从而为整个粒子系统调优。

### 粒子数上限超过30的粒子系统（Max Particles）

粒子系统在Unity项目中的运用非常普遍，可用来生成各种诸如下雨、飘雪和火焰等动态效果。下图是一个刚在Unity当中“出生”的粒子系统：

而规则中指出的粒子数上限，指的就是该组件同时能拥有的最大粒子数。

在粒子系统中，合理的粒子数会使得诸如火焰或者落叶等特效的表现效果恰到好处。而过多的粒子数不仅会造成内存上的大量占用，实际运行时也会给CPU和GPU的计算带来更大压力。

基于UWA工程师的经验总结和对业内大数据的统计分析，我们发现在一般情况下，粒子系统的粒子数上限不超过30，即可满足大部分情况下所需的粒子表现效果。

开发团队可以通过本条规则，依据实际的展示表现，为粒子系统设置合理的粒子数上限，在保留特效水平的前提下优化内存和运算开销。

### 引用纹理尺寸大于256的粒子系统

在粒子系统中，我们会需要引用纹理来为粒子“穿上衣服”，以此配合需要达成的各种特效展示效果。
针对单个粒子而言，纹理尺寸的增大，对于整体的粒子表现效果的提升可能并不会那么明显。UWA通过对行业大数据的分析发现：针对大部分粒子系统的使用，纹理尺寸达到256x256即可满足大部分的表现需求。

通过本条规则，大家可以过滤出那些引用纹理尺寸“偏大”的粒子系统，为那些展示效果变动不明显的粒子系统进行“瘦身”。既可以减轻内存和计算的压力，也能够空出宝贵的性能空间去用于那些更重要的粒子系统。

### 开启Prewarm的粒子系统

在Unity的粒子系统应用中，我们经常会接触到一个叫做“预热”（Prewarm）的概念。我们可以在粒子系统的初始化面板内进行Prewarm的相关设置。

开启Prewarm选项后，粒子系统会在加载后立刻执行一个完整的粒子发射周期，一般用于特定的粒子效果的展示需求。

最典型的就是火焰特效的应用，在某些场景过场中，例如战乱中一间燃烧的木屋。开启Prewarm选项，我们就能直接看到熊熊燃烧的大火，而不是看一遍火焰从小烧到大的过程（不然这就违和得离谱）。

在一些粒子系统渲染规模较大的场景中，如果开启Prewarm选项，会使得粒子系统在使用时的第一帧产生相对集中的CPU耗时，那么很可能会造成运行时局部卡顿，从而对整个项目的运行过程产生感官和体验上的明显影响。

所以本条规则会找出这些开启Prewarm的粒子系统，开发团队进行进一步的检查后，根据实际使用需求去决定是否需要关闭相关的粒子预热效果。

### 开启Collision或Trigger的ParticleSystem

在Unity中，粒子系统一般用于各种渲染效果，不具备实物特性。但在某些具体的应用中，我们希望粒子具有现实中的物理性质来更好地表现想要的效果。

比如在某些二战题材的军事游戏内，用粒子系统去表现M16防空车的弹幕射击。为了更好地实现曳光弹、燃烧弹的射击，碰撞和四散的效果，这时候就需要开启粒子系统的物理碰撞。

如图，这是粒子系统中的Trigger（触发器）和Collision（碰撞器）设置。简单来讲，合理使用这两个设置，就能很好地模拟出粒子的实物碰撞效果。甚至可以实现比如子弹跳弹后的变轨，雨水滴到湖面后的反弹等现实的物理性质。

不过这些物理碰撞效果的实现是以高额的物理计算消耗为代价的。在实际使用中，大部分的粒子系统只是承担了渲染的作用，并不涉及粒子与物体碰撞的效果反馈。所以在这种情况下，开启Collision或者Trigger并不会使得原有渲染效果有显著提升，反而会带来相当大的性能负担。

所以本条规则会找出这些粒子系统，以供开发团队检查，在确认当前ParticleSystem不需要实现物理特性后，开发团队就可以果断关闭相关属性设置以减小项目的性能开销和计算压力。

希望以上这些知识点能在实际的开发过程中为大家带来帮助。需要说明的是，每一项检测规则的阈值都可以由开发团队依据自身项目的实际需求去设置合适的阈值范围，这也是本地资源检测的一大特点。同时，[也欢迎大家来使用UWA推出的本地资源检测服务，可帮助大家尽早对项目建立科学的美术规范](https://blog.uwa4d.com/archives/pipelinesummary.html)。

### 开启各向异性过滤的纹理

在之前的文章[《纹理优化：不仅仅是一张图片那么简单》](https://blog.uwa4d.com/archives/UWA_Pipeline19.html)中，我们对纹理的过滤模式有过介绍，简单来讲是为了降低纹理到模型表面的这个过程中发生的“失真”现象。

相比于之前提到的各种过滤模式，纹理“贴”到物体表面时，各向异性过滤多考虑了纹理贴合与视野观察角度的关系。在这个前提下，如果在U、V方向上，纹理像素对应到物体表面的关系不是1:1时，它会按比例在各方向上进行采样不同数量的点，并进行计算以得到最终的对应关系。

在纹理的过滤模式中选择Bilinear（双线性过滤）或者Trilinear（三线性过滤）时，我们就可以对Aniso Level进行调整，范围是从0到16。

![img](http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/UWA_Pipeline31/5.png)

当我们把摄像机调成与纹理表面成一定角度时，Aniso Level的作用就会显示出来。如下图是nisoLevel设置为0或1时的纹理的表现（即不进行各向异性过滤）：

![img](http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/UWA_Pipeline31/6.png)

下图是AnisoLevel设置为9时（这时候进行了各向异性过滤）的贴图情况。对比两张图就能很明显地发现视野远端的清晰程度是完全不一样的。

![img](http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/UWA_Pipeline31/7.png)

开启各向异性过滤，在这种要考虑视野角度的情况下，可以很显著地提升纹理的表现效果，但代价是更高的GPU性能开销。而且各向异性过滤主要适用于大面积的地面与地形设置，对场景内的物体来讲，开启相关纹理的各向异性过滤就有“杀鸡用牛刀”的浪费之嫌了，表现效果上的提升并不足以抵消或平衡由此带来的性能消耗和渲染压力。

所以本条规则筛选出这些纹理后，开发团队要根据实际情况，在充分考量使用场景、表现效果和性能消耗的多方平衡后，再去决定是否需要保留开启各向异性过滤。

**粒子系统中使用了Standard Shader**

我们在之前的文章[《【Shader优化】破解变体的“影分身”之术》](https://blog.uwa4d.com/archives/UWA_Pipeline27.html)中，对Shader和相关的变体知识进行了较为详细地介绍，所以对Shader相关的知识，在此就不再赘述。

针对本条规则，对于使用了Standard Shader的粒子系统，Standard Shader可能生成非常多的变体，其加载耗时会非常高，ShaderLab内存占用也比较高，所以不建议项目团队直接在项目中使用。
