# Lua笔记

## 1、打印与注释

print("123");

-- 单行注释

--[[多行注释]] 

## 2、变量

-- nil 空

a = nil

-- number 数值

a = 1; a = 1.2

-- [[string 字符串Lua中的字符串通常表示“一个字符序列”。Lua完全采用8位编码。Lua的字符串是不可变的值。不能像C语言中那样直接修改字符串的某个字符，而是应该根据修改要求来创建一个新的字符串。Lua的字符串和其它对象都是自动内存管理机制所管理的对象，不需要担心字符串的内存分配和释放。在Lua中，字符串可以高效的处理长字符串。当字符串是多行存在时，可以使用“[[]]”符号来界定一个多行字符串，同时，Lua不会解释其中的转义序列。例如：]]

a = '123'; a = "123"

local page = [[  123

qwe

]] 

--boolean bool型

a = true;

-- type函数 获取变量类型； 返回类型的string描述

print(type(a))

-- 未声明的变量 默认值为nil

print(b)

-- function 函数

在Lua中，函数被当做值来对待，这表示函数可以存储在变量中，可以通过参数传递给其它函数，还可以作为其它函数的返回值。Lua既可以调用自身Lua语言编写的函数，又可以调用以C语言编写的函数。Lua所有的标准库都是用C语言写的。我在之后，还会详细的总结Lua中的函数的。在这里就说这么多。

-- table 表

table类型实现了关联数组，关联数组是一种具有特殊索引方式的数组；不仅可以通过整数来索引它，还可以使用字符串或其它类型的值（除了nil）来索引它。此外，table没有固定的大小，可以动态得添加任意数量的元素到一个table中。

在Lua中，table既不是“值”，也不是“变量”，而是对象。可以将table想象成一种动态分配的对象，程序中仅仅有一个队它们的引用（指针）。table的创建是通过“构造表达式”完成的，最简单的构造表达式就是{}。

table永远是匿名的，一个引用table的变量与table自身之间没有固定的关联性，例如以下代码：

local a = {} -- 创建一个table，并将它的引用存储在a a["x"] = 10 local b = a -- b与a引用同一个table print(b["x"]) b["x"] = 20 print(a["x"])

-- userdata 数据结构

userdata用于表示一种由应用程序或C语言库所创建的新类型。由于userdata类型可以将任意的C语言数据存储到Lua变量中。在Lua中，这种类型没有太多的预定义操作，只能进行赋值和相等性测试。

-- thread 协同程序

thread主要用于“协同程序”，在之后会继续总结的。这里就不做太多的总结。

## 3、表达式

### **算术操作符**

Lua支持常规的算术操作符有：”+”（加法）,”-“（减法）,”*”（乘法）,”/”（除法）,”^”（指数）,”%”（取模）,一元的”-“（负号）。所有的这些操作符都用于实数。例如：x^0.5将计算x的平方根，x^3将计算x的3次方。

### **关系操作符**

Lua提供的关系操作符有：”<“,”>”,”<=”,”>=”,”==”,”~=”；所有这些操作符的运算结果都是true或false。

操作符==用于相等性测试，操作符~=用于不等性测试。这两个操作符可以应用于任意两个值。如果两个值具有不同的类型，Lua就认为它们是不相等的；特别需要说明的是，nil只与其自身相等。

对于table、userdata和函数，Lua是作引用比较的。也就是说，**只有当它们引用同一个对象时**，才认为它们相等。

### **逻辑操作符**

Lua提供的逻辑操作符有and、or和not。与条件控制语句一样，所有的逻辑操作符将false和nil视为假，而将其它的任何东西视为真。对于操作符and来说，如果它的第一个操作数为假，就返回第一个操作数；不然就返回第二个操作数。对于操作符or来说，如果它的第一个操作数为真，就返回第一个操作数；不然就返回第二个操作数。这里和C++等语言是存在区别的，Lua的逻辑操作符并不是简单的返回true或false，而是返回操作数的值。例如以下代码：

print(4 and 5)               -->5 print(nil and 13)          -->nil print(false and 13)     -->false print(4 or 5)               -->4 print(false or 5)          -->5

and和or都使用“短路求值”，也就是说，它们只会在需要时才去评估第二个操作数。

### **字符串连接**

要在Lua中连接两个字符串，可以使用操作符“..”（两个点）。如果其任意一个操作数是数字的话，Lua会将这个数字转换成一个字符串。在Lua中，字符串是不可变的值，连接操作符只会创建一个新字符串，而不会对其原操作数进行任何修改。

### **table构造式**

构造式是用于创建和初始化table的表达式。最简单的构造式就是一个空构造式{}，用于创建一个空table。构造式还可以用于初始化数组，数组的下标从1开始。例如：

**local tbDays ={"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"} print(tbDays[1])          -->Sunday print(tbDays[2])          -->Monday print(tbDays[3])          -->Tuesday print(tbDays[4])          -->Wednesday print(tbDays[5])          -->Thursday print(tbDays[6])          -->Friday print(tbDays[7])          -->Saturday**

Lua还提供了一种特殊的语法用于初始化table：

**local tb1 = {x=10, y=20} print(tb1.x)          -->10 print(tb1["x"])          -->10**

除此之外，Lua还提供了一种更通用的格式，这种格式允许在方括号之间，显式地用一个表达式来初始化索引值，例如：

**local tb1 = {["+"] = "add", ["-"] = "sub", ["\*"] = "mul", ["/"] = "div"} print(tb1["+"])**

比如local tb1 = {x=10, y=20}这种构造方式，其实是和local tb1 = {[“x”] = 10, [“y”] = 20}是等价的。在实际编程中，这两种构造式，都可以替换的用。

## 4、语句

### **赋值**

赋值的基本含义是修改一个变量或一个table中字段的值，这个和其它语言没有多少区别，但是对于Lua，有一个特性，它允许“多重赋值”，也就是一下子将多个值赋予多个变量，例如以下代码：

local x1, x2 = 2, 4 print(x1)     -->2 print(x2)     -->4

在多重赋值中，Lua先对等号右边的所有元素求值，然后才执行赋值，例如以下用法，可以非常简便的交换两个元素的值：

local x1, x2 = 2, 4 x1, x2 = x2, x1 print(x1)     -->4 print(x2)     -->2

Lua总是会将等号右边值得个数调整到与左边变量的个数相一致，规则是：如果值得个数少于变量的个数，那么多余的变量**会被赋为nil**；如果值得个数更多的话，那么多余的值**会被忽略掉**。

### **局部变量与块**

相对于全局变量，Lua同时也提供了局部变量。通过local语句来创建局部变量：

i = 10     -->全局变量 local i = 10     -->局部变量

在Lua中，局部变量也是有作用范围的，也就是说，出了局部变量的作用范围，局部变量就会失去作用，这个和C++等高级语言是一样的道理。我们在编程的过程中，也可以使用do…end来显示的声明一个块，例如以下代码：

do     local a1 = 10     local a2 = 10 end          -->a1和a2的作用域到此结束

至于使用局部变量和全局变量，关系到编程风格和实际需要，这里不做多说。

### **控制结构**

几乎所有的语言都有控制结构，同样，对于Lua的控制结构是非常简单的。Lua提供了用于条件执行的if，循环的while、repeat和for。所有的控制结构都有一个显式的终止符：if、for和while以end作为结尾，repeat以until作为结尾。特别注意，在Lua中是不支持switch结构的。

if then else

if语句先测试其条件，然后根据测试结果执行then部分或者else部分，else部分是可选的。如果要编写嵌套的if，可以使用elseif，下面通过代码示例来说明if的使用。

if a < 0 then a = 0 end if a < b then retuan a else return b end if op == "+" then     r = a + b elseif op == "-" then     r = a - b elseif op == "*" then     r = a * b elseif op == "/" then     r = a / b end

while

Lua中的while与其它语言是一样的，示例代码如下：

local a = 10 while a > 0 do     a = a - 1     -- Do something else end

repeat

repeat就好比C++中的do…while结构，循环体至少会执行一次。repeat-until语句重复执行其循环体直到条件为真时结束。

在Lua中有两种for语句的形式：数字型for和泛型for

数字型for

数字型for的语法如下：

for var = exp1, exp2, exp3 do     -- Do something end

var从exp1变化到exp2，每次变化都以exp3作为步长进行递增，并执行一次do…end之间的代码。第三个表达式exp3是可选的，若不指定的话，Lua会将步长默认为1。例如以下代码：

for var = 1, 10 do     print(var) end for var = 10, 1, -1 do     print(var) end

在使用for时，需要注意以下两点：

1.for的exp1,exp2和exp3，这三个表达式是在循环开始前一次性求值得；并不会每次循环都进行求值；

2.控制变量var会被自动的声明为for语句的局部变量，并且仅在循环体内可见。

泛型for

泛型for循环通过一个迭代器函数来遍历所有值。在Lua的基础库中提供了ipairs，这是一个用于遍历数组的迭代器函数。从外观上看泛型for比较简单，但其实它是非常强大的。通过不同的迭代器，几乎可以遍历所有的东西。标准库提供了几种迭代器，包括用于迭代文件中每行的io.lines、迭代table元素的pairs、迭代数组元素的ipairs和迭代字符串中单词的string.gmatch等。当然了，我们也可以编写自己的迭代器，在以后的文章中，我会总结如何编写迭代器的。

### **break与return**

break和return语句用于跳出当前的块。这里的break、return和C++等语言是一样的。break语句用于结束一个循环，return语句用于从一个函数中返回结果。

## 5、函数

### **前言**

Lua中的函数和C++中的函数的含义是一致的，Lua中的函数格式如下：

function MyFunc(param)     -- Do something end

在调用函数时，也需要将对应的参数放在一对圆括号中，即使调用函数时没有参数，也必须写出一对空括号。对于这个规则只有一种特殊的例外情况：一个函数若只有一个参数，并且此参数是一个字符串或table构造式，那么圆括号便可以省略掉。看以下代码：

print "Hello World"          --> print("Hello World")等价 print [[a multi-line          message]]          -->print([[a multi-line                              -->               message]]) 等价 -- f是一个函数 f{x=10, y=20}               -->f({x=10, y=20}) 等价

上面代码的一些简便写法，如果不熟悉的话，在阅读别人的代码时，就会是一头雾水。

一个函数定义具有一个名称、一系列的参数和一个函数体。函数定义时，所定义的参数的使用方式与局部变量非常相似，它们是由调用函数时的“实际参数”初始化的。调用函数时提供的实参数量可以与形参数量不同。Lua会自动调整实参的数量，以匹配参数表的要求，若“实参多于形参，则舍弃多余的实参；若实参不足，则多余的形参初始化为nil”。这个与接下来要介绍的多重返回值非常相似。

### **多重返回值**

这个应该是Lua的一个特征吧。允许函数返回多个结果，只需要在return关键字后列出所有的返回值即可。以下根据带来来说明情况：

function foo0() end                         -- 无返回值 function foo1() return "a" end          -- 返回一个结果 function foo2() return "a", "b" end     -- 返回两个结果 -- 在多重赋值时，如果一个函数调用是最后，或仅有的一个表达式， -- 那么Lua会保留其尽可能多的返回值，用于匹配赋值变量 x, y = foo2()               -- x = "a", y = "b" x = foo2()                    -- x = "a", "b"被丢弃 x, y, z = 10, foo2()     -- x = 10, y = "a", z = "b" -- 如果一个函数没有返回值或者没有足够多的返回值，那么Lua会用 -- nil来补充缺失的值 x, y = foo0()               -- x = nil, y = nil x, y = foo1()               -- x = "a", y = nil x, y, z = foo2()          -- x = "a", y = "b", z = nil -- 如果一个函数调用不是一系列表达式的最后一个元素，那么将只产生一个值： x, y = foo2(), 20          -- x = "a", y = 20 x, y = foo0(), 20, 30     -- x = nil, y = 20, 30则被丢弃 -- table构造式可以完整的接收一个函数调用的所有结果，即不会有任何数量 -- 方面的调整 local t = {foo0()}          -- t = {}(一个空的table) local t = {foo1()}          -- t = {"a"} local t = {foo2()}          -- t = {"a", "b"} -- 但是，对于上述的行为，只有当一个函数调用作为最后一个元素时才会发生， -- 而在其他位置上的函数调用总是只产生一个结果值 local t = {foo0(), foo2(), 4}          -- t[1] = nil, t[2] = "a", t[3] = 4 -- 我们也可以在一个函数中，使用return返回另一个函数的返回值 function MyFunc()          -- 返回a     return foo1()          -- 注：这里是return foo1()，而不是return (foo1()) end -- return foo1()和return (foo1())是两个完全不同的意思 -- 将一个函数调用放入一对圆括号中，从而迫使它只返回一个结果 print((foo0()))          -- nil print((foo1()))          -- a print((foo2()))          -- a

### **变长参数**

在C语言中，函数可以接受不同数量的实参，Lua中的函数也可以接受不同数量的实参，例如以下代码：

-- 打印所有的参数 function VarArguments(...)     for i, v in ipairs{...} do          print(v)     end end VarArguments(1, 2, 3)

参数表中的3个点（…）表示该函数可接受不同数量的实参。当这个函数被调用时，它的所有参数都会被收集到一起。这部分收集起来的实参称为这个函数的“变长参数”。一个函数要访问它的变长参数时，仍需要用到3个点（…）。但不同的是，此时这3个点是作为一个表达式来使用的。在上例中，表达式{…}表示一个由所有变长参数构成的数组。在C语言中使用变长参数需要注意的问题，在Lua中同样需要注意。

通常一个函数在遍历其变长参数时只需要使用表达式{…}，这就像访问一个table一样，访问所有的变长参数。然而在某些特殊的情况下，变长参数中可能会包含一些故意传入的nil，那么此时就需要用select来访问变长参数了。调用select时，必须传入一个固定实参selector和一系列变长参数。如果selector为数字n，那么select返回它的第n个可变实参以及其后面的所有参数；否则selector只能为字符串“#”，这样select会返回变长参数的总数，请看以下代码：

for i = 1, select('#', ...) do    local arg = select(i, ...) -- 得到第i个参数    -- Do something else end

select(‘#’, …)会返回所有变长参数的总数，其中包括nil（还记得table.maxn么？）对于Lua 5.0版本来说，变长参数则有另外一套机制。声明函数的语法是一样的，也是将3个点作为最后一个参数。但Lua 5.0没有提供“…”表达式。而是通过一个隐含的局部table变量“arg”来接受所有的变长参数。这个table还有一个名为“n”的字段，用来记录变长参数的总数，例如以下代码：

function MyFunc(a, b, ...)     print(arg.n) end MyFunc(1, 2, 3, 4, 5)     -->3

这套旧机制的缺点在于，每当程序调用了一个具有变长参数的函数时，都会创建一个新的table。而在新机制中，只有在需要时才会去创建这个用于变长参数访问的table。这里只是对这个方法进行简单介绍，别在阅读别人的代码时，看不懂！！！

### **深入讨论函数**

在Lua中，函数与其它传统类型的值具有相同的权利。函数可以存储到变量或table中，也可以作为实参传递给其它函数，还可以作为其它函数的返回值。在Lua中有一个容易混淆的概念是，函数与所有其它值一样都是匿名的，即它们都没有名称。当讨论一个函数名时，实际上是在讨论一个持有某函数的变量，例如以下代码：

-- 我们经常这样定义函数 function foo(x) return 2 * x end -- 实际上，这只是一种“语法糖”而已； -- 上述代码只是下面代码的一种简化书写形式 foo = function (x) return 2 * x end

实际上，一个函数定义实际就是一条语句（更准确地说是一条赋值语句），这条语句创建了一种类型为“函数”的值，并将这个值赋予一个变量。由于函数在Lua中就是一个普通的值，所以不仅可以将其存储在全局变量中，还可以存储在局部变量甚至table的字段中。

### **内嵌函数**

若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这个特征叫做“词法域”。我们来看看下面一段有趣的代码：

function newCounter()     local i = 0     return function () -- 匿名函数          i = i + 1          return i     end end c1 = newCounter() print(c1())     -->输出什么？ print(c1())     -->又输出什么？

如果你很明白上面的输出，很明白上面的代码，那么闭合函数这一小节就不需要阅读了。在上述代码中，有一个变量i，对于函数newCounter来说，i是一个局部变量，但是对于匿名函数来说，当它访问这个i时，i既不是全局变量，也不是局部变量，对于我们来说，我们称这样的变量为一个**“非局部的变量”**。下面这段代码也是同样的道理：

function newCounter(i)     return function () -- 匿名函数          i = i + 1          return i     end end c1 = newCounter(10) print(c1())     -->输出什么？ print(c1())     -->又输出什么？

匿名函数访问了一个“非局部的变量”i，该变量用于保持一个计数器。乍一看，由于创建变量i的函数，也就是newCounter已经返回，所以之后每次调用匿名函数时，i都应该是已经超出了作用范围。但是，Lua会以closure的概念来正确地处理这种情况。在这里简单的讲，一个closure就是一个函数加上该函数所需访问的所有“非局部的变量”。如果再次调用newCounter，那么它会创建一个新的局部变量i，从而将得到一个新的closure。在后续的总结中，我会专门总结一篇关于Lua中的闭包的博文，敬请期待。

### **非全局的函数**

由于函数和普通变量一样，所以函数不仅可以存储在全局变量中，还可以存储在table的字段中，或局部变量中。我们可以把函数存在一个table中，比如以下代码：

Lib = {} Lib.foo = function (x, y) return x + y end Lib.goo = function (x, y) return x - y end

只要将一个函数存储在一个局部变量中，就得到了一个“局部函数”，也就是说这个函数只能在某个特定的作用域内才有效。我们可以这样定义一个局部的函数：

local f = function (<参数>)     <函数体> end -- Lua还提供另一种特殊的“语法糖” local function f (<参数>)     <函数体> end

有的时候，我们需要进行函数的前置声明，比如以下代码：

local f, g function f()     <一些其它操作>     g() end function g()     <一些其它操作>     f() end

## 6、lua中的闭包

**什么是闭包？**

闭包在Lua中是一个非常重要的概念，闭包是由函数和与其相关的引用环境组合而成的实体。我们再来看一段代码：

function newCounter()     local i = 0     return function () -- 匿名函数          i = i + 1          return i     end end c1 = newCounter() print(c1())  print(c1())

根据刚刚说的闭包的概念，结合上面的代码，来说说这个概念。闭包=函数+引用环境。上述代码中的newCounter函数返回了一个函数，而这个返回的匿名函数就是闭包的组成部分中的函数；引用环境就是变量i所在的环境。实际上，闭包只是在形式和表现上像函数，但实际上不是函数，我们都知道，函数就是一些可执行语句的组合体，这些代码语句在函数被定义后就确定了，并不会再执行时发生变化，所以函数只有一个实例。而闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例，就好比相同的类代码，可以创建不同的类实例一样。在看别人的文章时，看到有这样的说法：子函数可以使用父函数中的局部变量，这种行为就叫做闭包！这种说法其实就说明了闭包的一种表象，让我们从外在形式上，能更好的理解什么是闭包。至于深层次的闭包，我们接着继续。

**再看闭包**

看过我博客的朋友都清楚，我之前的博客都是写的关于C++的东西，对于学习C++的我，理解Lua的闭包时，确实存在一些“难度”。首先，在Lua中，创建一个函数，就像定义一个普通类型值一样的，也就是我之前的博文中说的，Lua中的函数和和普通类型是没有区别的。Lua中的函数就是所谓的“第一类值”，它可以被存放在变量或数据结构中，可以当做参数传递给另一个函数，可以是一个函数的返回值，还可以在运行期间被创建。Lua中的函数就是这样的一种“东西”，它很灵活。还记得我在《Lua中的函数》博文中提到的“非局部的变量”这个概念么？这是一个非常很重要的概念，它可以理解为不是在局部作用范围内定义的一个变量，同时，它又不是一个全局变量，也就是大家说的upvalue，由于有了这样的一种变量的存在，就成全了Lua中的闭包。这种变量主要应用在嵌套函数和匿名函数里。我们都知道，可以在Lua的函数中再定义函数，也就是内嵌函数，内嵌函数可以访问外部函数已经创建的所有局部变量，而这些变量就被称为该内嵌函数的upvalue，upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，比如以下代码：

function Fun1()     local iVal = 10          -- upvalue     function InnerFunc1()     -- 内嵌函数          print(iVal)          --     end      function InnerFunc2()     -- 内嵌函数          iVal = iVal + 10     end      return InnerFunc1, InnerFunc2 end -- 将函数赋值给变量，此时变量a绑定了函数InnerFunc1, b绑定了函数InnerFunc2 local a, b = Fun1() -- 调用a a()          -->10 -- 调用b b()          -->在b函数中修改了upvalue iVal -- 调用a打印修改后的upvalue a()          -->20

上述这段简单的代码，就验证了在内嵌函数中是共享upvalue的，就好比C++类中的成员函数可以访问和修改成员变量一样。

**使用闭包**

可以看到闭包是数据和行为的结合体，就好比C++中的类，这样就使得闭包具有较好的抽象能力，在某些场合下，我们需要记住某次调用完成以后数据的状态，就好比C++中的static类型的变量，每次调用完成以后，static类型的变量并不会被清除。使用闭包就可以很好的完成该功能，在下一篇博文中，我将会讲到使用闭包完成迭代器功能。

## 7、Lua中的迭代器与泛型for

**前言**

迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器都需要在每次成功调用之后保存一些状态，这样才能知道它所在的位置及如何走到下一个位置，通过之前博文的总结，闭包对于这样的任务提供了极佳的支持。现在我们就用代码来实现一个简单的迭代器。

function values(tb)     local i = 0     return function ()          i = i + 1          return tb[i]     end end local testTb = {10, 20, 30} for value in values(testTb) do     print(value) end

这就是一个最简单的迭代器，使用闭包来完成整个任务；这只是一个简单的例子，接下来，再看看泛型for的语义。

lua表索引从1开始

**泛型for的语义**

泛型for比较复杂，它在循环过程内保存了迭代器函数。它实际上保存着3个值：一个迭代器函数、一个恒定状态和一个控制变量。接下来，分别进行总结。

泛型for的语法如下：

for <var-list> in <exp-list> do      end

其中，是一个或多个变量名的列表，以逗号分隔；是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器函数的调用。例如：

for k, v in pairs(t) do print(k, v) end

for做的第一件事就是对in后面的表达式求值，这些表达式应该返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。这里和多重赋值是一样的，只有最后一个表达式才会产生多个结果，并且只会保留前3个值，多余的值会被丢弃；而不够的话，就以nil补足。

在初始化完成以后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环就终止，否则，for执行它的循环体，随后再次调用迭代器函数，并重复这个过程。在前言部分的代码中，只是返回了迭代器函数，并没有返回恒定状态和控制变量。下面通过代码来说明这个问题，比如：

for var_1, ..., var_n in  do  end -- 就等价于以下代码： do     local _f, _s, _var =     -- 返回迭代器函数、恒定状态和控制变量的初值     while true do          local var_1, ..., var_n = _f(_s, _var)          _var = var_1          if _var == nil then break end                    end     end end

**无状态的迭代器**

所谓“无状态的迭代器”，就是一种自身不保存任何状态的迭代器。因此，我们可以在多个循环中使用同一个无状态的迭代器，避免创建新的闭包的开销。

在每次迭代中，for循环都会用恒定状态和控制变量来调用迭代器函数。一个无状态的迭代器可以根据这两个值来为下次迭代生成下一个元素。这类迭代器的代表就是ipairs。它可以用来迭代一个数组的所有元素。如下述演示代码：

local aTb = {"One", "Two", "Three"} for i, v in ipairs(aTb) do     print(i, v) end

在这里，迭代器状态就是需要遍历的table（一个恒定状态，它不会在循环中改变）及当前的索引值（控制变量）。我们可以使用Lua代码来实现ipairs，大概就如下代码：

local function iter(a, i)     i = i + 1     local v = a[i]     if v then          return i, v     end end function ipairs(a)     return iter, a, 0 end

函数pairs与ipairs类似，也是用于遍历一个table中的所有元素。不同的是，它的迭代器函数是Lua中的一个基本函next。

function pairs(a)     return next, t, nil end

在调用next(t, k)时，k是table t的一个key。此调用会以table中的任意次序返回一组值：此table的下一个key，及这个key所对应的值。而调用next(t, nil)时，返回table的第一组值。若没有下一组值时，next返回nil。所以，我们也可以使用next来判断一个table是否为空。

对于大家经常迷惑的ipairs和pairs的区别，在这里就能看的一清二楚了，ipairs只能用于遍历index是整型的table，同时，由于ipairs返回的控制变量初值为0，这就决定了，ipairs只能访问index从1开始的key和value；ipairs不能返回nil，当key对应的值为nil时，就直接终止遍历；而pairs则没有要求。关于ipairs和pairs的具体差异，请参考这篇博文：[点这里](http://www.92csz.com/00/1038.html)。

当然了，有了无状态的迭代器，就有了有状态的迭代器了，有状态的迭代器就是专门用一个table来保存状态；在无状态的迭代器中，我们每一次都是迭代一个table，这个table就是一个无状态的table，它不会再遍历的过程中发生变化，而有状态的迭代器，则会在遍历的过程中对迭代的table进行变更，迭代的table的状态也随之发生了变化。这里不做详细的总结。

**总结**

如下代码所示，pairs遍历到空时会继续遍历，ipairs不会

local testTb = {10, nil, 20, 30}

for value in pairs(testTb) do

​     print(value)

end

for _,v in pairs(testTb) do

​     print(_,v)

end

for _ in ipairs(testTb) do

​     print(_)

end

for _,v in ipairs(testTb) do

​     print(_,v)

end

## 8、表

### 字典

字典的本质就是表

访问：可以通过中括号访问、点访问（不能是数字）

修改、新增、删除、遍历

### 类

#### 成员变量的声明：

​	表内声明、表外声明

#### 成员函数的声明：

##### 	表内声明

##### 	表外声明

​		和函数的两种声明方式相同：变量的形式，function + 名字的形式；

​		在表内部函数想要访问变量或方法是必须要知道他们来自哪里

##### 	点和冒号

​		点正常调用

​		冒号默认把调用者作为第一个参数传入

##### 	冒号可以声明函数

​		只能是外部function + 名字的方式声明，相当于有一个默认参数

​		self就是用冒号声明时作为第一个参数的代表

### 公共操作

table.方法名进行条用	

插入、排序、删除、拼接

## 9、多lua脚本的执行

全局变量和局部变量：局部变量关键字local

多脚本执行：require("脚本名")，require之后脚本中的内容才会执行

脚本卸载：package.loaded["脚本名"]得到一个是否加载的bool，

​					package.loaded["脚本名"] = nil 赋值为nil就是卸载 

_G: 	  总表，存储所有全局变量

​			本地变量加local不会存储再_G

## 10、特殊用法

多变量赋值:不够补空，多了省略

多返回值：不够补空，多了省略

and or：nil、false是假，短路，可以连接任何东西

三目运算: (x > y) and x or y

## 11、协同程序

创建：coroutine.create()返回thread

​			coroutine.wrap() 返回function

运行：coroutine.resume(thread)

​			fuction()

挂起：coroutine.yield(返回参数)

状态：coroutine.status()	dead、running、supended，normal(携程A唤醒携程B时，A的状态)

​			coroutine.running() 返回运行中的携程

## 12、元表

### 元表概念

--任何表变量都可以设置元表

--任何表变量都可以是元表
--字表中一些特定操作会执行元表的中内容

### 设置元表得到元表

setmetatable

getmetatable

### 特定操作

__tostring 当string处理时找元表

__call 当函数处理时找元表

运算符重载

__index： 找不到属性时,会找元表__index指向的表

__newindex： 元表存在newindex表时， 字表设置不存在的属性时，会改变元表的__newindex指向的表

### raw

rawset、rawget

## 13、面向对象

### 封装

表：表现类的一种形式

实现new方法：本质上是创建一张空表，设置元表，设置--index表

修改创建出来的对象的属性变量：为空表新建了一个变量

冒号：self代表函数调用者

### 继承

写了继承方法

_G根据字符串创建一个新的类

元表和_index完成了一个继承的表现

### 多态

相同方法名，子类执行不同逻辑

直接重写方法

保留父类逻辑：加入自定义的base属性，子表的base指向父表，subclass方法中赋值

通过base调用父类方法时，不要使用冒号调用，自己手动传入第一个参数

## 14、自带库

string、table、math、os

系统时间戳	os.time()

时间戳	os.time({year = 2014,month=10,day=1})

当前时间	os.date("*t")	--表的信息

绝对值	math.abs

弧度转角度	math.deg

三角函数	math.cos

向上取整	math.floor

向下取整	math.ceil

最大最下	math.max	math.min

小数分离	math.modf

幂运算	math.pow

随机种子	math.randomseed(os.time())

随机数	math.random(100)

开放	math.sqrt

lua加载路径	package.path

## 15、垃圾回收

关键字：

--内存占用字节	collectgarbage("count")

--垃圾回收	collectgarbage("collect")

lua中有自动定时的GC 耗性能

unity热更新开发过程中在切换场景或内存达到瓶颈时手动调用lua的gc